<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>"OpenCV DNN Batch Inference in C++"</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="C/C++ OpenCV Image Classification Batch Inference OpenCV DNN OpenCV has a DNN module, which is powerful, efficient, and easy to use. To implement..." />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">BigBook's Tech Blog</a></h1>
                <nav><ul>
                    <li class="active"><a href="/category/misc.html">misc</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/opencv-dnn-batch-inference-in-c.html" rel="bookmark"
           title="Permalink to "OpenCV DNN Batch Inference in C++"">"OpenCV DNN Batch Inference in C++"</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2021-08-23T00:00:00+02:00">
                Published: Mon 23 August 2021
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/bigbook.html">"BigBook"</a>
        </address>
<p>In <a href="/category/misc.html">misc</a>.</p>

</footer><!-- /.post-info -->      <ul>
<li>C/C++</li>
<li>OpenCV</li>
<li>Image Classification</li>
<li>Batch Inference</li>
<li>OpenCV DNN</li>
</ul>
<hr>
<p>OpenCV has a DNN module, which is powerful, efficient, and easy to use. To implement a DNN inference application, we need only to call a couple of APIs which are offered by OpenCV DNN module. The basic routine of implementation a DNN inference code by OpenCV is as below. </p>
<blockquote>
<ul>
<li>Initialization. Creating the cv::dnn::Net object by reading in the network weight. (caffe/onnx...)</li>
<li>Preprocessing. Determine shape of input data of the network. Reshape the raw input image(s) to match the input data shape. This step always combined some other operatations such as normalization.</li>
<li>Inference. Call inference method by the created cv::dnn::Net object.</li>
<li>Postprocessing. Decoding the output data and do further wrangling.</li>
</ul>
</blockquote>
<p>In my opinion, as the network weights are already determined, the most important parts of the deployment are pre&amp;postprocessing. You need to figure out exactly what shape of input data is, and what the normalization method is (mean/std value). In post processing, things may be much more complicated. Some tasks are easy to implement, classification tasks for instance. Some tasks  will be much harder to implement, such as object detection/segmentation tasks. You need to do a lot of work to crack the data wrangling problems, and sometimes may need to rewrite some operatations yourself from scratch, just because there is no corresponding method  with the original python implementation in C++.</p>
<p>In this article, I will describe a simple implementation of image classification by OpenCV DNN module, and give a fast tour of batch inference.</p>
<h2>Important APIs</h2>
<p>To load the weights into device and create the DNN Net object, Opencv DNN module provided a readNet method. It supports ONNX/Caffe/TF/OpenVINO...</p>
<p>In this article, we use Caffe model as the example.</p>
<div class="highlight"><pre><span></span><code><span class="n">Net</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">dnn</span><span class="o">::</span><span class="n">readNetFromCaffe</span><span class="p">(</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">prototxt</span><span class="p">,</span><span class="w"> </span>\
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">caffeModel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">String</span><span class="p">())</span>
</code></pre></div>

<blockquote>
<p>This API will read the network weights in Caffe format.</p>
<p>Parameters
- <code>prototxt</code>  path to the .prototxt file with text description of the network architecture.
- <code>caffeModel</code> path to the .caffemodel file with learned network.</p>
<p>Returns
Net object.</p>
</blockquote>
<p>We also need to call <code>blobFromImage</code> to do some preprocessing on the input cv::Mat image.</p>
<div class="highlight"><pre><span></span><code><span class="n">Mat</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">dnn</span><span class="o">::</span><span class="n">blobFromImage</span><span class="p">(</span><span class="w"> </span><span class="n">InputArray</span><span class="w"> </span><span class="n">image</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">double</span><span class="w"> </span><span class="n">scalefactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="n">Size</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Size</span><span class="p">(),</span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="n">Scalar</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">mean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Scalar</span><span class="p">(),</span>
<span class="w">                            </span><span class="kt">bool</span><span class="w"> </span><span class="n">swapRB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">bool</span><span class="w"> </span><span class="n">crop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">int</span><span class="w"> </span><span class="n">ddepth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CV_32F</span><span class="p">)</span>
</code></pre></div>

<blockquote>
<p>Creates 4-dimensional blob from image. Optionally resizes and crops image from center, subtract mean values, scales values by scalefactor, swap Blue and Red channels.</p>
<p>Parameters
- <code>image</code> input image (with 1-, 3- or 4-channels).
- <code>size</code>  spatial size for output image
- <code>mean</code>  scalar with mean values which are subtracted from channels. Values are intended to be in (mean-R, mean-G, mean-B) order if image has BGR ordering and swapRB is true.
- <code>scalefactor</code>   multiplier for image values.
- <code>swapRB</code>    flag which indicates that swap first and last channels in 3-channel image is necessary.
- <code>crop</code>  flag which indicates whether image will be cropped after resize or not
- <code>ddepth</code>    Depth of output blob. Choose CV_32F or CV_8U.
if crop is true, input image is resized so one side after resize is equal to corresponding dimension in size and another one is equal or larger. Then, crop from the center is performed. If crop is false, direct resize without cropping and preserving aspect ratio is performed.</p>
<p>Returns
4-dimensional Mat with NCHW dimensions order.</p>
</blockquote>
<h2>Difference Between cv::Mat Image and Blob</h2>
<p>The mainly difference is the data format. In normal cv::Mat image, the data is arranged in HWC format, like <code>RGBRGB...RGB</code>. But when turned into blobs, it becomes NCHW format, as most neural networks does.</p>
<p>In normal cv::Mat image, we get width and height by member <code>cols</code> and <code>rows</code>, but in blob, these two vars is -1. We get blob size by <code>blob.size(0)</code> <code>blob.size(1)</code> etc. This is useful when we need to decompose the result mat from batch inference.</p>
<h2>Include stuffs we need</h2>
<p>We firstly include all the stuffs to use OpenCV DNN. Then we  declare a Global cv::dnn:Net Variable. This var will load net weights from your disk and do nearly all the nn calculation tasks.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;opencv2/core.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;opencv2/dnn.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;opencv2/core/cuda.hpp&quot;</span>

<span class="c1">// Global net variable.</span>
<span class="n">cv</span><span class="o">::</span><span class="n">dnn</span><span class="o">::</span><span class="n">Net</span><span class="w"> </span><span class="n">net</span><span class="p">;</span>
</code></pre></div>

<p>Suppose we have a caffe model, we pass the <code>.prototxt</code> file name to the var <code>model_deploy</code>, and <code>.caffemodel</code> file to var <code>model_bin</code>. We do the init works in this <code>init</code> function:</p>
<p>Note that, we open the cuda support for faster inference. If you want to add CUDA support too, please refer to <a href="http://bigbook.plus/2021/08/16/opencv-cmake-vs2019/">Build OpenCV 4.5.2 with CUDA support</a>. </p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">model_deploy</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">model_bin</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">net</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">dnn</span><span class="o">::</span><span class="n">readNetFromCaffe</span><span class="p">(</span><span class="n">model_deploy</span><span class="p">,</span><span class="w"> </span><span class="n">model_bin</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Let CUDA be the calculation device.</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">cuda</span><span class="o">::</span><span class="n">setDevice</span><span class="p">(</span><span class="n">cuda_id</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">.</span><span class="n">setPreferableBackend</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">dnn</span><span class="o">::</span><span class="n">DNN_BACKEND_CUDA</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">.</span><span class="n">setPreferableTarget</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">dnn</span><span class="o">::</span><span class="n">DNN_TARGET_CUDA</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h2>Single Image Inference</h2>
<p>Now we try to do the single image inference.</p>
<p>It's simple. Call <code>blobFromImage</code> method to turn the image into a blob, then set this blob as the input to <code>net</code> by <code>net.setInput</code>, finally we got the output <code>cv::Mat</code> by <code>net.forward()</code>.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">single_inference</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;empty image!!!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">blob</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">dnn</span><span class="o">::</span><span class="n">blobFromImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="w"> </span><span class="mi">224</span><span class="p">),</span><span class="w"> </span>\
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="w">    </span><span class="n">net</span><span class="p">.</span><span class="n">setInput</span><span class="p">(</span><span class="n">blob</span><span class="p">);</span>

<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">net</span><span class="p">.</span><span class="n">forward</span><span class="p">();</span>

<span class="w">    </span><span class="n">post_process</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>After we got the original output by neural network, we need to do the post-processing. In this sample, we assume that the final layer of model is just softmax layer, which as most model does, and we only use the <code>cv::minMaxLoc</code> to get the biggest score and position.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">post_process</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">min_val</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">max_val</span><span class="p">;</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="w"> </span><span class="n">min_pos</span><span class="p">;</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="w"> </span><span class="n">max_pos</span><span class="p">;</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">minMaxLoc</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">min_val</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">max_val</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">min_pos</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">max_pos</span><span class="p">);</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">label</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_pos</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;result: &quot;</span><span class="o">&lt;&lt;</span><span class="n">label</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Now we can do the calculation in the main function.</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="o">!=</span><span class="mi">4</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Usage: ./cv-dnn-test /path/to/prototxt /path/to/caffemodel /path/to/image.jpg&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

<span class="w">    </span><span class="n">init</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

<span class="w">    </span><span class="n">single_inference</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h2>Batch Inference</h2>
<p>Batch inference swallowed multiple images in one forward pass. So we call <code>blobFromImages</code> to turn multiple images into a blob. Dimension <code>N</code> in <code>NCHW</code> is the image count.</p>
<div class="highlight"><pre><span></span><code><span class="n">Mat</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">dnn</span><span class="o">::</span><span class="n">blobFromImages</span><span class="p">(</span><span class="n">InputArrayOfArrays</span><span class="w"> </span><span class="n">images</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">double</span><span class="w"> </span><span class="n">scalefactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span>
<span class="w">                            </span><span class="n">Size</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Size</span><span class="p">(),</span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="n">Scalar</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">mean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Scalar</span><span class="p">(),</span>
<span class="w">                            </span><span class="kt">bool</span><span class="w"> </span><span class="n">swapRB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">bool</span><span class="w"> </span><span class="n">crop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">int</span><span class="w"> </span><span class="n">ddepth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CV_32F</span><span class="p">)</span>
</code></pre></div>

<blockquote>
<p>Creates 4-dimensional blob from series of images. Optionally resizes and crops images from center, subtract mean values, scales values by scalefactor, swap Blue and Red channels.</p>
<p>Parameters
- <code>images</code>    input images (all with 1-, 3- or 4-channels).
- <code>size</code>  spatial size for output image
- <code>mean</code>  scalar with mean values which are subtracted from channels. Values are intended to be in (mean-R, mean-G, mean-B) order if image has BGR ordering and swapRB is true.
- <code>scalefactor</code>   multiplier for images values.
- <code>swapRB</code>    flag which indicates that swap first and last channels in 3-channel image is necessary.
- <code>crop</code>  flag which indicates whether image will be cropped after resize or not
- <code>ddepth</code>    Depth of output blob. Choose CV_32F or CV_8U.</p>
<p>if crop is true, input image is resized so one side after resize is equal to corresponding dimension in size and another one is equal or larger. Then, crop from the center is performed. If crop is false, direct resize without cropping and preserving aspect ratio is performed</p>
</blockquote>
<p>The output need to be decomposed. In this model, every single image output is a 1-d softmax results. After Batch Inference, we got N times 1-d softmax arrays, which is a 2-d cv::Mat. Every line represents a single image softmax results. We use the <code>rowRange</code> method to cut the cv::Mat result.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">batch_inference</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">images</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">blob</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">dnn</span><span class="o">::</span><span class="n">blobFromImages</span><span class="p">(</span><span class="n">images</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="w"> </span><span class="mi">224</span><span class="p">),</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="n">net</span><span class="p">.</span><span class="n">setInput</span><span class="p">(</span><span class="n">blob</span><span class="p">);</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">net</span><span class="p">.</span><span class="n">forward</span><span class="p">();</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">out_single</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">post_process</span><span class="p">(</span><span class="n">out_single</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h2>Overall Demo</h2>
<p>We demostrate a full implementation code here to illustrate what we discussed in the previous text. We get the caffe model of ImageNet from ()[https://github.com/cvjena/cnn-models/releases/download/v1.0/cnn-models_cvgj.zip]. </p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;opencv2/core.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;opencv2/dnn.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;opencv2/highgui.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;opencv2/imgproc.hpp&quot;</span>

<span class="k">typedef</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Result</span><span class="p">;</span>

<span class="n">Result</span><span class="w"> </span><span class="nf">post_process</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">min_val</span><span class="p">,</span><span class="w"> </span><span class="n">max_val</span><span class="p">;</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="w"> </span><span class="n">min_loc</span><span class="p">,</span><span class="w"> </span><span class="n">max_loc</span><span class="p">;</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">minMaxLoc</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">min_val</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">max_val</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">min_loc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">max_loc</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">max_val</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">max_loc</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">max_loc</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">max_val</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Result</span><span class="o">&gt;</span><span class="w"> </span><span class="n">batch_post_process</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span><span class="w"> </span><span class="n">outs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Result</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">outs</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outs</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">post_process</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
<span class="w">        </span><span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">dnn</span><span class="o">::</span><span class="n">Net</span><span class="w"> </span><span class="n">net</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">dnn</span><span class="o">::</span><span class="n">readNetFromCaffe</span><span class="p">(</span><span class="s">&quot;models/deploy.prototxt&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;models/resnet50_cvgj_iter_320000.caffemodel&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">image_files</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;data/a.jpeg&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;data/b.jpeg&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;data/c.jpeg&quot;</span><span class="p">};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&gt;</span><span class="w"> </span><span class="n">images</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">image_files</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="n">image_files</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="n">images</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">img</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">blobs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">dnn</span><span class="o">::</span><span class="n">blobFromImages</span><span class="p">(</span><span class="n">images</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="w"> </span><span class="mi">224</span><span class="p">),</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">104</span><span class="p">,</span><span class="w"> </span><span class="mi">117</span><span class="p">,</span><span class="w"> </span><span class="mi">123</span><span class="p">),</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="n">net</span><span class="p">.</span><span class="n">setInput</span><span class="p">(</span><span class="n">blobs</span><span class="p">);</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">outs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">net</span><span class="p">.</span><span class="n">forward</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">outs</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">outs</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">batch_post_process</span><span class="p">(</span><span class="n">outs</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">result_text</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="w">        </span><span class="n">sprintf</span><span class="p">(</span><span class="n">result_text</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%d %.2f&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="w">        </span><span class="n">cv</span><span class="o">::</span><span class="n">putText</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">result_text</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">),</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">FONT_HERSHEY_SIMPLEX</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">window_name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="w">        </span><span class="n">sprintf</span><span class="p">(</span><span class="n">window_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;image %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="n">window_name</span><span class="p">,</span><span class="w"> </span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>