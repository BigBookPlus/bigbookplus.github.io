<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>"使用Docker辅助图像识别程序开发：在Docker中访问GPU和、USB相机以及网络"</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Docker Image Recognition GPU Docker Web Camera USB Camera 引言 在操作系统中发行应用程序，尤其是python应用程序，其环境配置常常是分发过程中的重要一环。如果像开发 …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">BigBook's Tech Blog</a></h1>
                <nav><ul>
                    <li class="active"><a href="/category/misc.html">misc</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/shi-yong-dockerfu-zhu-tu-xiang-shi-bie-cheng-xu-kai-fa-zai-dockerzhong-fang-wen-gpuhe-usbxiang-ji-yi-ji-wang-luo.html" rel="bookmark"
           title="Permalink to "使用Docker辅助图像识别程序开发：在Docker中访问GPU和、USB相机以及网络"">"使用Docker辅助图像识别程序开发：在Docker中访问GPU和、USB相机以及网络"</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2022-11-03T00:00:00+01:00">
                Published: Thu 03 November 2022
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/bigbook.html">"BigBook"</a>
        </address>
<p>In <a href="/category/misc.html">misc</a>.</p>

</footer><!-- /.post-info -->      <ul>
<li>Docker</li>
<li>Image Recognition</li>
<li>GPU Docker</li>
<li>Web Camera</li>
<li>USB Camera</li>
</ul>
<hr>
<h2>引言</h2>
<p>在操作系统中发行应用程序，尤其是python应用程序，其环境配置常常是分发过程中的重要一环。如果像开发的时候那样手动构建，一方面工作量难以承受，另一方面经常会出现各种各样的问题。在不同的目标主机上手动构建环境，会受到目标操作系统的版本、文件系统、所安装软件包的情况影响。而且开发时所使用的一些默认安装包，到了发布的时候可能已经都被更新过，所以手动构建要求使用的包版本号也精确记录。</p>
<h2>安装和配置</h2>
<p>安装GPU docker，首先需要安装docker，然后在docker的基础上安装nvidia-docker。</p>
<h3>安装docker</h3>
<p>参考链接 <a href="https://docs.docker.com/engine/install/ubuntu">https://docs.docker.com/engine/install/ubuntu</a></p>
<h3>安装nvidia-docker</h3>
<p>参考链接 <a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker">https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker</a></p>
<h2>在docker中显示GUI</h2>
<p>如果在Docker中开发的是带有GUI的应用程序，也就是在docker中显示GUI，需要启动支持GUI的docker镜像。</p>
<p>首先配置一下xhost</p>
<div class="highlight"><pre><span></span><code>xhost<span class="w"> </span>+local:docker
</code></pre></div>

<p>或者</p>
<div class="highlight"><pre><span></span><code>xhost<span class="w"> </span>+
</code></pre></div>

<p>启动docker，由于需要docker中显示GUI，所以加入参数</p>
<div class="highlight"><pre><span></span><code>-v<span class="w"> </span>/tmp/.X11-unix:/tmp/.X11-unix<span class="w"> </span>-e<span class="w"> </span><span class="nv">DISPLAY</span><span class="o">=</span><span class="nv">$DISPLAY</span>
</code></pre></div>

<p>完整指令如下：</p>
<div class="highlight"><pre><span></span><code>docker<span class="w"> </span>run<span class="w"> </span>--name<span class="w"> </span>mydocker<span class="w"> </span>--gpus<span class="w"> </span>all<span class="w"> </span>--shm-size<span class="o">=</span>1g<span class="w"> </span>--ulimit<span class="w"> </span><span class="nv">memlock</span><span class="o">=</span>-1<span class="w"> </span>-it<span class="w"> </span>-v<span class="w"> </span>/tmp/.X11-unix:/tmp/.X11-unix<span class="w"> </span>-e<span class="w"> </span><span class="nv">DISPLAY</span><span class="o">=</span><span class="nv">$DISPLAY</span><span class="w"> </span>snn-server:basic
</code></pre></div>

<p>注意，这里是启动了GPU docker，--gpus all是指定使用所有的GPU，如果只使用一块GPU，可以指定为--gpus 0。</p>
<h2>在Docker中访问usb相机</h2>
<p>如果需要在docker中访问usb相机，需要在启动docker的时候，追加以下参数</p>
<div class="highlight"><pre><span></span><code>-v<span class="w"> </span>/dev/video0:/dev/video0<span class="w"> </span>--device<span class="o">=</span>/dev/video0
</code></pre></div>

<p>这样就把宿主机的/dev/video0映射到docker中的/dev/video0，然后在docker中就可以访问到相机了。</p>
<div class="highlight"><pre><span></span><code>docker<span class="w"> </span>run<span class="w"> </span>--name<span class="w"> </span>mydocker<span class="w"> </span>--gpus<span class="w"> </span>all<span class="w"> </span>--shm-size<span class="o">=</span>1g<span class="w"> </span>--ulimit<span class="w"> </span><span class="nv">memlock</span><span class="o">=</span>-1<span class="w"> </span>-v<span class="w"> </span>/dev/video0:/dev/video0<span class="w"> </span>--device<span class="o">=</span>/dev/video0<span class="w"> </span>-it<span class="w"> </span>-v<span class="w"> </span>/tmp/.X11-unix:/tmp/.X11-unix<span class="w"> </span>-e<span class="w"> </span><span class="nv">DISPLAY</span><span class="o">=</span><span class="nv">$DISPLAY</span><span class="w"> </span>myimage:latest
</code></pre></div>

<h2>在Docker镜像中开放端口</h2>
<p>如果需要从docker中对外提供服务，需要在docker中向宿主机进行端口映射，才可以从宿主机访问到docker中的服务。</p>
<p>Docker中的端口映射，需要在启动docker的时候，加入参数</p>
<div class="highlight"><pre><span></span><code>-p<span class="w"> </span><span class="m">8080</span>:8080<span class="w">  </span>
</code></pre></div>

<p>这样，宿主机的8080端口就映射到docker中的8080端口了。</p>
<div class="highlight"><pre><span></span><code>docker<span class="w"> </span>run<span class="w"> </span>--name<span class="w"> </span>mydocker<span class="w"> </span>-p<span class="w"> </span><span class="m">8080</span>:8080<span class="w">  </span>--gpus<span class="w"> </span>all<span class="w"> </span>--shm-size<span class="o">=</span>1g<span class="w"> </span>--ulimit<span class="w"> </span><span class="nv">memlock</span><span class="o">=</span>-1<span class="w"> </span>-v<span class="w"> </span>/dev/video0:/dev/video0<span class="w"> </span>--device<span class="o">=</span>/dev/video0<span class="w"> </span>-it<span class="w"> </span>-v<span class="w"> </span>/tmp/.X11-unix:/tmp/.X11-unix<span class="w"> </span>-e<span class="w"> </span><span class="nv">DISPLAY</span><span class="o">=</span><span class="nv">$DISPLAY</span><span class="w"> </span>myimage:latest
</code></pre></div>

<h2>开启更多的GPU功能支持</h2>
<p>我的程序后面用到了GPU的一些高级功能，比如GPU的nvcuvid解码，这需要做更多的设置，否则在程序启动对应解码库的时候，报错如下：</p>
<div class="highlight"><pre><span></span><code><span class="go">[h264_cuvid @ 0x7f2d48048580] Cannot load libnvcuvid.so.1</span>
</code></pre></div>

<p>这是因为docker中的GPU环境，没有开启nvcuvid的支持，需要在启动docker的时候，加入参数</p>
<div class="highlight"><pre><span></span><code>--runtime<span class="o">=</span>nvidia<span class="w"> </span>-e<span class="w"> </span><span class="nv">NVIDIA_VISIBLE_DEVICES</span><span class="o">=</span>all<span class="w"> </span>-e<span class="w"> </span><span class="nv">NVIDIA_DRIVER_CAPABILITIES</span><span class="o">=</span>compute,utility,video<span class="w"> </span>
</code></pre></div>

<p>当然，这需要可能需要您的宿主机本身可以支持这方面的功能</p>
<h2>创建本地镜像中心</h2>
<p>开发中和开发好的镜像都可以选择在dockerhub上暂存，不同阶段或者用途的docker则以不同的tag或仓库名称来区分管理。免费的dockerhub账号有一个私有仓库和无限的公共仓库可供使用。不管是用来开发的镜像，还是准备分发的镜像，体积都比较大，一般要以GB为单位，因特网直接上传下载可能需要等待较长时间；因此，也可以在局域网中配置一台硬盘空间较大的主机，做为内网的镜像中心。</p>
<p>选好机器后，在机器上做好docker的基本配置，然后在联网状态下，执行以下命令：</p>
<div class="highlight"><pre><span></span><code>docker<span class="w"> </span>run<span class="w"> </span>-d<span class="w"> </span>-p<span class="w"> </span><span class="m">5000</span>:5000<span class="w"> </span>--restart<span class="o">=</span>always<span class="w"> </span>--name<span class="w"> </span>xy-registry<span class="w"> </span>-v<span class="w"> </span>/home/centos/registry:/registry<span class="w">  </span>registry:latest
</code></pre></div>

<p>可以看到，内网镜像中心，其实也是一个docker镜像的形式，把registry镜像拉下来，自动启动服务运行在机器上。需要配置的仅是完成端口映射和目录绑定。</p>
<h3>一些可选参数</h3>
<ul>
<li>-d，后台运行容器</li>
<li>-p 5000:5000 ，映射容器5000端口至宿主机5000端口。</li>
<li>--restart always，设置重新启动策略，在docker重新启动时自动重新启动容器my-registry。</li>
<li>--name 给容器命名。my-registry，</li>
<li>-v /registry:/registry，把docker容器中/registry目录的数据加载到宿主机的/registry目录，宿主机的/registry目录如果不存在会自动创建。目的是为了防止docker私有仓库这个容器被删除时，仓库里的镜像也会被删除。宿主机查看到的私有仓库镜像就在这个目录中。</li>
<li>-e REGISTRY_STORAGE_DELETE_ENABLED，设置是否允许删除仓库存储的镜像。</li>
<li>-e REGISTRY_HTTP_ADDR=0.0.0.0:5000，设置镜像仓库地址。</li>
</ul>
<h3>上传镜像</h3>
<div class="highlight"><pre><span></span><code>docker<span class="w"> </span>commit<span class="w"> </span>container_id<span class="w"> </span>ip:port/image_name:tag
docker<span class="w"> </span>push<span class="w"> </span>ip:port/image_name:tag
</code></pre></div>

<h2>回收空间</h2>
<p>首先查看docker的磁盘空间占用情况</p>
<div class="highlight"><pre><span></span><code>docker<span class="w"> </span>system<span class="w"> </span>df
</code></pre></div>

<p>您可以看到，docker的磁盘空间占用情况，包括镜像、容器、卷和网络的占用情况。
清理的方式有两种，一种是清理所有的无用镜像，一种是清理指定的镜像。</p>
<h3>清理所有的无用镜像</h3>
<div class="highlight"><pre><span></span><code>docker<span class="w"> </span>image<span class="w"> </span>prune
</code></pre></div>

<h3>清理指定的镜像</h3>
<p>首先列出所有的镜像</p>
<div class="highlight"><pre><span></span><code>docker<span class="w"> </span>images
</code></pre></div>

<p>删除指定的镜像</p>
<div class="highlight"><pre><span></span><code>docker<span class="w"> </span>rmi<span class="w"> </span>image_id
</code></pre></div>

<h2>GPU Docker with Anaconda</h2>
<p>再进一步，如果想要一个GPU docker，又想要在docker中安装anaconda，那么就需要在docker中安装cuda和anaconda了。
cuda的docker可以直接从docker hub拉取，anaconda的docker需要自己构建。 
也是可以考虑两种方式，一种是构建DockerFile，一种是直接手动构建镜像。</p>
<h3>第一种方式:构建DockerFile</h3>
<div class="highlight"><pre><span></span><code><span class="k">FROM</span><span class="w"> </span><span class="s">nvidia/cuda:11.3.0-devel-ubuntu20.04</span>

<span class="c"># Add some dependencies</span>
<span class="k">RUN</span><span class="w"> </span>apt-get<span class="w"> </span>clean<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>apt-get<span class="w"> </span>update<span class="w"> </span>-y<span class="w"> </span>-qq
<span class="k">RUN</span><span class="w"> </span>apt-get<span class="w"> </span>install<span class="w"> </span>-y<span class="w"> </span>curl<span class="w"> </span>git<span class="w"> </span>build-essential

<span class="k">ENV</span><span class="w"> </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">&quot;/root/anaconda2/bin:</span><span class="si">${</span><span class="nv">PATH</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="k">RUN</span><span class="w"> </span>curl<span class="w"> </span>--silent<span class="w"> </span>-O<span class="w"> </span>https://repo.anaconda.com/archive/Anaconda3-2023.03-Linux-x86_64.sh<span class="w"> </span><span class="se">\</span>
<span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>bash<span class="w"> </span>Anaconda3-2023.03-Linux-x86_64.sh<span class="w"> </span>-b<span class="w"> </span>-p<span class="w"> </span>/root/anaconda3

<span class="k">RUN</span><span class="w"> </span>pip<span class="w"> </span>install<span class="w"> </span>keras<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>conda<span class="w"> </span>install<span class="w"> </span>pygpu
<span class="k">RUN</span><span class="w"> </span>/bin/bash
</code></pre></div>

<h3>第二种方式:直接手动构建镜像</h3>
<p>首先选择一个GPU docker拉取，这里我们选择的是配备有cuda11.3的ubuntu 20.04版本的镜像。当前时间是2023年，cuda已经更新到了12，ubuntu也已经发行到了版本号22，可以看出所选的版本是比较次新的版本，算是对兼容性的一个折衷。</p>
<div class="highlight"><pre><span></span><code>docker<span class="w"> </span>pull<span class="w"> </span>nvidia/cuda:11.3.0-devel-ubuntu20.04
</code></pre></div>

<p>然后参照上一节的DockerFile安装anaconda。</p>
<h2>Reference</h2>
<p>https://blog.csdn.net/renfeigui0/article/details/103755823</p>
<p>https://cloud.tencent.com/developer/article/1581147</p>
<p>https://medium.com/better-programming/docker-tips-clean-up-your-local-machine-35f370a01a78</p>
<p><a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker">https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker</a></p>
<p><a href="https://docs.docker.com/engine/install/ubuntu">https://docs.docker.com/engine/install/ubuntu</a></p>
<p>https://github.com/NVIDIA/nvidia-docker/issues/766</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>